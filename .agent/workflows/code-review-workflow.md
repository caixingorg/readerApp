# 代码审查工作流

> 确保代码质量、知识共享、团队成长的系统化审查流程

## 适用场景

- Pull Request 的代码审查
- 定期代码质量检查
- 新人代码指导
- 架构变更评审

## 角色定义

| 角色 | 职责 | 时间投入 |
|------|------|----------|
| **作者 (Author)** | 提交代码，响应评审意见 | 30-60 分钟 |
| **审查者 (Reviewer)** | 审查代码，提供反馈 | 15-45 分钟 |
| **维护者 (Maintainer)** | 最终批准，合并代码 | 5-15 分钟 |

## 前置条件

### 作者准备
- [ ] 代码已自审（运行 Lint、类型检查、测试）
- [ ] PR 描述完整（背景、方案、测试）
- [ ] 提交记录清晰（符合 Conventional Commits）
- [ ] 冲突已解决

### 审查者准备
- [ ] 了解 PR 背景和目标
- [ ] 本地环境可运行（如需要）
- [ ] 预留足够时间（避免匆忙审查）

## 执行步骤

### 阶段 1：审查前准备 (5 分钟)

**目标**：理解 PR 背景和范围

#### 作者：提交前自审

> 📋 **代码规范检查**：使用 [code-standards.md](code-standards.md) 完整检查清单

1. 运行完整检查：
   ```bash
   npm run type-check
   npm run lint
   npm test
   npm run build  # 确保可构建
   ```

2. 自我代码审查：
   - [ ] 无调试代码（console.log, debugger）
   - [ ] 无硬编码值
   - [ ] 无 TODO 注释（除非有明确计划）
   - [ ] 命名清晰
   - [ ] 逻辑易懂

3. 完善 PR 描述：
   ```markdown
   ## 变更类型
   - [ ] 新功能
   - [ ] Bug 修复
   - [ ] 重构
   - [ ] 文档更新
   
   ## 背景
   [为什么做这个变更]
   
   ## 技术方案
   [怎么实现的]
   
   ## 测试
   - [ ] 单元测试
   - [ ] 功能测试
   - [ ] 回归测试
   
   ## 截图（如适用）
   
   ## 检查清单
   - [ ] 遵循项目规则
   - [ ] 无 TS/Lint 错误
   - [ ] 测试通过
   - [ ] 文档已更新
   ```

#### 审查者：了解背景
1. 阅读 PR 描述和相关 Issue
2. 查看文件变更范围
3. 评估审查重点

✅ **检查点**：
- PR 描述完整清晰
- 审查者理解变更背景
- 变更范围合理（建议 < 500 行）

### 阶段 2：代码审查 (20-40 分钟)

**目标**：系统化审查代码质量

#### 审查维度与权重

**🔴 必须项（阻塞合并）**
- 功能正确性
- 安全漏洞
- 严重性能问题
- 破坏现有功能

**🟡 重要项（强烈建议修改）**
- 代码可维护性
- 命名和注释
- 错误处理
- 测试覆盖

**🟢 建议项（可选）**
- 优化建议
- 代码风格细节
- 更好的实现方式

#### 分层审查法

**Level 1: 宏观审查（5 分钟）**
1. 整体架构：
   - [ ] 文件组织合理
   - [ ] 模块划分清晰
   - [ ] 依赖关系正确

2. 变更范围：
   - [ ] 变更与 PR 描述一致
   - [ ] 无无关改动
   - [ ] 无意外的大范围重构

**Level 2: 功能审查（10 分钟）**
3. 功能逻辑：
   - [ ] 实现符合需求
   - [ ] 边界条件处理正确
   - [ ] 错误处理完善
   - [ ] 异步逻辑正确

4. 安全性：
   - [ ] 无 SQL 注入风险
   - [ ] 无 XSS 漏洞
   - [ ] 敏感数据已加密
   - [ ] 权限验证正确
   - [ ] 输入验证充分

**Level 3: 代码质量（10 分钟）**

> 📋 **详细标准**：参考 [code-standards.md](code-standards.md#🔍-标准检查清单) 各项规范

5. 类型安全（TypeScript）：
   - [ ] 无 `any` 类型滥用
   - [ ] 类型定义完整
   - [ ] 无类型断言滥用（`as`）

6. 可读性：
   - [ ] 命名清晰有意义
   - [ ] 逻辑易于理解
   - [ ] 复杂逻辑有注释
   - [ ] 函数职责单一

7. 可维护性：
   - [ ] 无重复代码
   - [ ] 复杂逻辑已抽离
   - [ ] 魔法数字已定义为常量
   - [ ] 遵循项目规范

8. 性能：
   - [ ] 无不必要的重渲染
   - [ ] 无重复计算
   - [ ] 大数据处理合理
   - [ ] 图片已优化

**Level 4: 测试与文档（5 分钟）**
9. 测试：
   - [ ] 关键逻辑有单元测试
   - [ ] 测试用例覆盖充分
   - [ ] 测试可读性好

10. 文档：
    - [ ] 复杂逻辑有注释
    - [ ] API 文档已更新
    - [ ] README 已更新（如需要）

✅ **检查点**：
- 已完成分层审查
- 识别出需要改进的地方
- 准备好反馈意见

### 阶段 3：提供反馈 (10-15 分钟)

**目标**：给出建设性、可执行的反馈

#### 反馈原则

**清晰分类**：
```markdown
🔴 **必须修改 (Required)**
- 这会导致安全问题

🟡 **建议修改 (Suggested)**  
- 这样可读性更好

🟢 **可选优化 (Optional)**
- 可以考虑使用更简洁的写法

💡 **学习建议 (Learning)**
- 这里可以了解一下 React useMemo 的使用场景
```

**具体可执行**：
❌ **模糊反馈**：
```
这段代码不好
```

✅ **清晰反馈**：
```
🟡 **建议修改**
这里使用了嵌套三层的 if，可读性较差。

建议重构为卫语句（Guard Clause）：
```typescript
if (!user) return null;
if (!user.permissions) return null;
if (!user.permissions.includes('admin')) return null;
// 主逻辑
```
```

**保持友好**：
❌ **负面表达**：
```
你怎么能用 any？这是基本错误！
```

✅ **正面表达**：
```
🟡 **建议修改**
这里使用了 `any` 类型，会失去 TypeScript 的类型保护。
建议定义具体的接口类型，可以参考其他类似代码的实现。
```

**认可优点**：
```
✨ **做得好**
这个 hook 的抽离很好，逻辑清晰且可复用！
```

#### 反馈模板

**代码注释方式**：
```typescript
// 🔴 必须修改：这里没有处理 null 的情况
const userName = user.name.toUpperCase();

// 建议改为：
const userName = user?.name?.toUpperCase() ?? 'Unknown';
```

**PR 评论方式**：
```markdown
## 整体评价
代码整体质量不错，逻辑清晰。有几处需要调整。

## 必须修改 🔴
1. [文件:行号] 安全问题：用户输入未验证
2. [文件:行号] 类型错误：返回类型不匹配

## 建议修改 🟡
1. [文件:行号] 可读性：函数过长，建议拆分
2. [文件:行号] 性能：可以使用 useMemo 优化

## 可选优化 🟢
1. [文件:行号] 代码风格：可以使用解构赋值

## 做得好的地方 ✨
- hooks 抽离得很好
- 测试覆盖充分
```

✅ **检查点**：
- 反馈清晰具体
- 分清必须/建议/可选
- 语气友好建设性

### 阶段 4：互动与改进 (10-30 分钟)

**目标**：通过讨论达成共识

#### 作者：响应反馈
1. 逐条回复评审意见：
   ```markdown
   > 🟡 建议使用 useMemo 优化
   
   已修改，感谢建议！commit: abc123
   ```

2. 如有疑问，主动讨论：
   ```markdown
   > 🟡 建议拆分为多个函数
   
   这里拆分的话会增加很多参数传递，是否可以保持现状？
   或者有更好的拆分方式吗？
   ```

3. 推送修改：
   ```bash
   git add .
   git commit -m "refactor: apply review feedback"
   git push
   ```

#### 审查者：持续跟进
1. 检查修改：
   - [ ] 必须项已全部修改
   - [ ] 建议项大部分采纳
   - [ ] 新的修改没有引入问题

2. 如仍有问题，继续讨论

3. 达成一致后批准：
   ```markdown
   ## ✅ 批准合并
   所有关键问题已解决，代码质量符合标准。
   感谢你的认真修改！
   ```

✅ **检查点**：
- 所有必须项已解决
- 双方达成共识
- 准备合并

### 阶段 5：合并与总结 (5 分钟)

**目标**：安全合并并记录学习

#### 合并前最终检查
1. CI/CD 检查：
   - [ ] 所有自动化测试通过
   - [ ] 构建成功
   - [ ] 代码覆盖率达标

2. 冲突检查：
   - [ ] 无合并冲突
   - [ ] 基于最新主分支

#### 合并策略
- **Squash Merge**：多个提交合并为一个（推荐）
- **Merge Commit**：保留所有提交历史
- **Rebase Merge**：线性历史

#### 合并后
1. 删除功能分支（如适用）
2. 关闭相关 Issue
3. 通知相关人员

#### 知识沉淀（可选但推荐）
```markdown
## 本次审查学习点
- 学习了 React useMemo 的使用场景
- 了解了 XSS 防护的最佳实践
- 发现团队新的代码规范
```

✅ **检查点**：
- 代码已成功合并
- 相关流程已完成
- 知识已沉淀

## 审查效率优化

### 小 PR 原则
**建议 PR 大小**：
- 理想：< 200 行
- 可接受：200-500 行
- 需拆分：> 500 行

**过大 PR 的处理**：
- 建议作者拆分为多个 PR
- 或分阶段审查

### 时间管理
- 单次审查时间：30-45 分钟
- 超过时建议休息或分批审查
- 避免疲劳审查（质量下降）

### 工具辅助
- 使用 GitHub/GitLab 的代码审查功能
- 使用代码差异工具
- 使用自动化检查减少人工审查负担

## 常见问题

**Q: 作者不接受我的建议怎么办？**
A: 
1. 区分必须项和建议项，必须项坚持，建议项可妥协
2. 通过讨论理解对方考虑
3. 如确实是原则问题，升级到团队讨论
4. 保持开放心态，可能对方有更好的理由

**Q: 审查时发现大问题怎么办？**
A: 
1. 立即标记为"必须修改"
2. 如问题严重，建议作者重新设计
3. 不要因为"已经写了很多代码"而降低标准
4. 帮助作者找到更好的方案

**Q: 审查花费时间太长？**
A: 
1. 检查 PR 是否过大，建议拆分
2. 使用分层审查法，先关注核心问题
3. 利用自动化工具减少琐碎检查
4. 团队约定审查时间上限

**Q: 如何避免过度吹毛求疵？**
A: 
1. 区分原则性问题和个人偏好
2. 团队约定明确的代码规范
3. 对于风格问题，遵循自动化工具（Prettier）
4. 保持"完成优于完美"的平衡

**Q: 新人代码如何审查？**
A: 
1. 更加耐心和详细
2. 不仅指出问题，还解释原因
3. 提供示例代码
4. 认可做得好的地方，鼓励成长
5. 可以进行面对面讲解

## 审查清单速查表

```markdown
## 快速审查清单

### 功能性 ✅
- [ ] 实现符合需求
- [ ] 边界条件处理
- [ ] 错误处理

### 安全性 🔒
- [ ] 无注入风险
- [ ] 输入验证
- [ ] 权限检查

### 代码质量 💎
- [ ] 无 TS/Lint 错误
- [ ] 命名清晰
- [ ] 逻辑简洁
- [ ] 无重复代码

### 性能 ⚡
- [ ] 无明显性能问题
- [ ] 资源使用合理

### 测试 🧪
- [ ] 测试覆盖充分
- [ ] 测试可读性

### 文档 📚
- [ ] 注释清晰
- [ ] 文档已更新
```

## 最佳实践

### ✅ 应该做的

1. **及时审查**：收到审查请求后 24 小时内响应
2. **分批审查**：大 PR 分多次审查，每次 30-45 分钟
3. **正面反馈**：认可做得好的地方
4. **具体建议**：给出可执行的改进方案
5. **保持学习**：审查也是学习机会

### ❌ 不应该做的

1. **拖延审查**：长时间不响应
2. **走马观花**：不认真看代码就批准
3. **人身攻击**：批评人而不是代码
4. **完美主义**：过度纠结细节
5. **单向沟通**：不接受讨论

## 快捷指令

- **/review-start**: 开始代码审查，生成审查清单
- **/review-feedback**: 生成反馈模板
- **/review-approve**: 检查是否满足批准条件

## 团队文化

优秀的代码审查文化应该：
- **建设性**：帮助改进而非批评
- **教育性**：互相学习成长
- **尊重性**：尊重作者的努力
- **高标准**：坚持代码质量
- **高效率**：快速响应，聚焦重点
